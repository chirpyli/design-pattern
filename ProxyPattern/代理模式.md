**Proxy模式——为其他对象提供一种代理以控制对这个对象的访问。** 在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。


**解决的问题场景：** 在直接访问对象时会带来问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层，从而实现了逻辑和实现的彻底解耦。

**优点：**

- 职责清晰。真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。
- 代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。
- 高扩展性


**代理模式的组成：**
抽象角色：通过接口或抽象类声明真实角色实现的业务方法。
代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。


**模式结构：**
一个是真正的你要访问的对象(目标类)，一个是代理对象,真正对象与代理对象实现同一个接口,先访问代理类再访问真正要访问的对象。

代理模式分为静态代理、动态代理。

- 静态代理——是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。
- 动态代理——是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。


>具体实现上，其实就是先定义抽象类，把代理需要的接口定义好，然后实现代理类，实现抽象类定义的接口，具体的工作仍交由真实角色完成，代理角色只是实现了一层包装。代理是轻量级的，仅仅实现代理的功能。
```c++
#include<iostream>
using namespace std;

//抽象类
class Subject {
public:
	Subject(){}
	virtual ~Subject(){}
	//抽象角色：通过接口或抽象类声明真实角色实现的业务方法。
	virtual void Request()=0;//接口
};

//委托类
class ConcreteSubject:public Subject {
public:
	ConcreteSubject(){}
	~ ConcreteSubject(){}
	//真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。
	void Request()
	{
		cout<<"代理实现请求！"<<endl;
	}
};

//代理类
class Proxy {
public:
	Proxy():_sub(NULL){}
	Proxy(Subject* sub):_sub(sub){}
	~Proxy(){
		if(_sub!=NULL){
			delete _sub;
		}
	}
	//代理角色：实现抽象角色，是真实角色的代理，
	void Request()
	{
		_sub->Request();	//通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
	}

private:
	Subject* _sub;
};

int main() {
	//代理模式的最大好处就是实现了逻辑和实现的彻底解耦
	Subject* sub=new ConcreteSubject();
	Proxy* p=new Proxy(sub);
	p->Request();//p的Request请求实际上是交给了sub来实际执行
	return 0;
}
```
